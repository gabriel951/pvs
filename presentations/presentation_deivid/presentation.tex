\documentclass{beamer}

    %Load Configuration File
    \input{Preamble/config}

    %Load Notation
    \input{Preamble/notation}

    %Title Page Settings
    \title{Nominal Disunification}
    \subtitle{Seminários Teoria da Computação - UnB}
    \date{\today}
    \author{Deivid Vale, Advisor: Daniele Nantes }
    \institute{Department of Mathematics - University of Brasilia}

    \begin{document}

    \maketitle

    \begin{frame}{Table of contents}
        \setbeamertemplate{section in toc}[sections numbered]
        \tableofcontents[hideallsubsections]
    \end{frame}

    \section{Nominal Terms and Syntax}

    \frame{
        \frametitle{Nominal Terms}
        
        Consider countable disjoint sets of \textit{meta-variables} (or just \textit{variables}) $\var = \{ X, Y, Z, \dots \}$ and atoms $\atomSet = \{ a, b, c, d, \dots \}$.

    }

    \begin{frame}{Nominal Terms}
        \begin{definition}[Nominal Terms]\label{definition:nominal-terms} The set $\terms$ of all nominal terms is inductively generated by the following grammar:
            $$s,t,u,v \ \ ::= \ \ a \ \ | \ \ \pAction{\pi}{X} \ \ | \ \ \abs{a}{t} \ \ | \ \ f(t_1, \dots, t_n) $$
        \end{definition}
        Terms are called, respectively, \textbf{atoms}, \textbf{moderated variable}, \textbf{abstractions}, and \textbf{function application}.
    \end{frame}

    \begin{frame}{Permutation Action}
        \begin{definition}\label{definition:object-level-permutation-action}
            The \textbf{object-level} action of a permutation $\pi$ on a term $t$ is defined by induction on the structure of $t$, as follows:
            \begin{align*}
                \pAction{\pi}{a} \equiv \pi(a) \quad \pAction{\pi}{(\pAction{\gamma}{X})} & \equiv \pAction{(\pi \cdot \gamma)}{X} \quad \pAction{\pi}{\abs{a}{t}} \equiv \abs{\pAction{\pi}{a}}{(\pAction{\pi}{t})} \\
                \pAction{\pi}{f(t_1,\dots,t_n})                                           & \equiv f(\pAction{\pi}{t_1},\dots,\pAction{\pi}{t_n})
            \end{align*}
        \end{definition}
    \end{frame}

    \begin{frame}{Substitutions}
        \begin{definition}\label{definition:substitution-meta-level}
            The \textbf{meta-level} action of a substitution $\sigma$ on a term $t$, denoted as $t\sigma$, is inductively defined by:
            \begin{align*}
                a\sigma \equiv a \quad (\pAction{\pi}{X})\sigma & \equiv \pAction{\pi}{(X\sigma)} \quad (\abs{a}{t})\sigma \equiv \abs{a}{(t\sigma)} \\
                f(t_1,\dots,t_n)\sigma                          & \equiv f(t_1 \sigma, \dots, t_n \sigma)
            \end{align*}
        \end{definition}
    \end{frame}


    \begin{frame}{Permutation and Substitution Action}
        \begin{lemma}[Commutation Lemma]\label{lemma:commutation-lemma}
            $\pAction{\pi}{(t \sigma)} \equiv (\pAction{\pi}{t})\sigma$.
        \end{lemma}
    \end{frame}

    \section{Freshness and Equality}

    \begin{frame}{Freshness Constraints and Contexts}
        \begin{definition}[Contexts]
            A \textit{freshness constraint} is a pair $a \fresh t$ of an atom $a$ and a term $t$. Call freshness constraints $a \fresh a$ and $a \fresh X$ primitive and write $\Delta$ and $\nabla$ for finite sets of primitive freshness constraints and call them \textbf{freshness contexts}.

            We say a context $\Delta$ is consistent iff it does not contain any freshness constraint of the form $a \fresh a$.
        \end{definition}
    \end{frame}

    \begin{frame}{Derivation Rules for Freshness}
        \begin{table}[ht]
            {\small
                \hrule
                \vspace{10pt}
                \begin{prooftree}
                    \AxiomC{}
                    \RightLabel{($\fresh ab$)}
                    \UnaryInfC{$a \fresh b$}
                    \DisplayProof
                    \defaultHypSeparation
                    \hspace{1cm}
                    \AxiomC{$\pi^{-1}(a) \fresh X $}
                    \RightLabel{($\fresh X$) ($\pi \neq \permID$)}
                    \UnaryInfC{$a \fresh \pAction{\pi}{X} $}
                    \vspace{1cm}
                    \DisplayProof
                    \defaultHypSeparation
                    \hspace{1cm}
                    \AxiomC{}
                    \RightLabel{($\fresh a$)}
                    \UnaryInfC{$ a \fresh \abs{a}{t}$}
                \end{prooftree}
                \begin{prooftree}
                    \AxiomC{$a \fresh t$}
                    \RightLabel{($\fresh b$)}
                    \UnaryInfC{$a \fresh \abs{b}{t}$}
                    \DisplayProof
                    \defaultHypSeparation
                    \hspace{1cm}
                    \AxiomC{$a \fresh t_1 \cdots a \fresh t_n$}
                    \RightLabel{($\fresh f$)}
                    \UnaryInfC{$a \fresh f(t_1, \dots, t_n) $}
                \end{prooftree}
                \hrule
            }
            \caption{Derivation rules for freshness}
            \label{table:fresh-constraints-deduction-system}
        \end{table}
    \end{frame}

    \begin{frame}{Derivation Rules for $\alpha$-equivalence}
        \begin{table}[ht]
            {\small
                \hrule
                \vspace{10pt}
                \begin{prooftree}
                    \AxiomC{}
                    \RightLabel{($\fresh ab$)}
                    \UnaryInfC{$a \aeq a$}
                    \DisplayProof
                    \defaultHypSeparation
                    \hspace{1cm}
                    \AxiomC{$\Delta \vdash \dset{\pi}{\gamma} \fresh X $}
                    \RightLabel{(Ds)}
                    \UnaryInfC{$\pAction{\pi}{X} \aeq \pAction{\gamma}{X}$}
                    \vspace{1cm}
                    \DisplayProof
                    \defaultHypSeparation
                    \hspace{1cm}
                    \AxiomC{$t_1 \aeq u_1 \cdots t_n \aeq u_n$}
                    \RightLabel{(F)}
                    \UnaryInfC{$f(t_1, \dots, t_n) \aeq f(u_1, \dots, u_n)$}
                \end{prooftree}
                \begin{prooftree}
                    \AxiomC{$t \aeq u$}
                    \RightLabel{(Abs-a)}
                    \UnaryInfC{$\abs{a}{t} \aeq \abs{a}{u}$}
                    \DisplayProof
                    \defaultHypSeparation
                    \hspace{0.5cm}
                    \AxiomC{$\pAction{\swapping{a}{b}}{t} \aeq u \quad \Delta \vdash b \fresh t$ }
                    \RightLabel{(Abs-b)}
                    \UnaryInfC{$\abs{a}{t} \aeq \abs{b}{u}$}
                \end{prooftree}
                \hrule
            }
            \caption{Derivation rules for $\alpha$-equivalence}
            \label{table:alpha-equality-deduction-system}
        \end{table}
    \end{frame}

    \begin{frame}{Judgment Forms}
        Nominal algebra (\cite{gabbay:nomuae}) has two judgment forms:
        \begin{enumerate}
            \item A \textit{freshness judgment form} $\Delta \vdash a \fresh t$.
            \item An \textit{equality judgment form} $\Delta \vdash t \aeq u$.
        \end{enumerate}
    \end{frame}

    \begin{frame}{Derivability}
        We define a \textit{notion of derivability} by the natural deduction rules given in Tables \ref{table:fresh-constraints-deduction-system} and \ref{table:alpha-equality-deduction-system}.
        \begin{enumerate}
            \item We say $\Delta \vdash a \fresh t$ is a valid judgment when there exists a derivation of $a \fresh t$  using the elements of $\Delta$ as assumptions.
            \item We also say $\Delta \vdash t \aeq u$ is a valid judgment when there exists a derivation of $t \aeq u$ using elements of $\Delta$ as assumptions.
        \end{enumerate}
    \end{frame}

    \section{Nominal Unification}
    \begin{frame}{Unification Problems}
        \begin{definition}
            A \textit{unification problem} $P$ is a finite set
            $$P = \pair{a_1 \freshPr u_1, \cdots, a_n \freshPr u_j}{s_1 \eqUnif t_1, \cdots , s_n \eqUnif t_n}$$
            of \textit{freshness problems} $a_i \freshPr u_i$ and \textit{equational problems} $s_k \eqUnif t_k$.
        \end{definition}
    \end{frame}

    \begin{frame}{Simplification Rules on Problems}
        \begin{table}[ht]
            {\small
                \hrule
                \vspace{10pt}
                \begin{align*}
                    a \fresh b, P                   & \implies P                                              \\
                    a \fresh \pAction{\pi}{X}, P    & \implies \pi^{-1}(a) \fresh X, P \quad \pi \neq \permID \\
                    a \fresh \abs{a}{t}, P          & \implies P                                              \\
                    a \fresh \abs{b}{t}, P          & \implies a \fresh t, P                                  \\
                    a \fresh f(t_1, \cdots, f_n), P & \implies a \fresh t_1, \cdots, a \fresh t_n, P
                \end{align*}
                \hrule
            }
            \caption{Simplification rules for freshness}
            \label{table:simplification-rules-freshness}
        \end{table}
    \end{frame}

    \begin{frame}{Simplification Rules on Problems}
        \begin{table}[ht]
            {\small
                \hrule
                \vspace{10pt}
                \begin{align*}
                    a \aeq a, P                                     & \implies P                                                 \\
                    \pAction{\pi}{X} \aeq \pAction{\gamma}{X}, P    & \implies \dset{\pi}{\gamma}\fresh X, P                     \\
                    f(s_1, \cdots, s_n) \aeq f(t_1, \cdots, t_n), P & \implies s_1 \aeq t_1, \cdots, s_n \aeq t_n, P             \\
                    \abs{a}{t} \aeq \abs{a}{u}, P                   & \implies t \aeq u, P                                       \\
                    \abs{b}{l} \aeq \abs{a}{r}, P                   & \implies \pAction{\swapping{a}{b}}{l} \aeq r, a \fresh l,P
                \end{align*}
                \hrule
            }
            \caption{Simplification rules for $\alpha$-equivalence}
            \label{table:simplification-rules-alpha-equiv}
        \end{table}
    \end{frame}

    \begin{frame}{Properties of Simplification Rules}
        \begin{lemma}
            The relation $\implies$ is confluent and strongly normalizing.
        \end{lemma}
    \end{frame}

    \begin{frame}{Unification Normal Forms}
        We write the \textit{unique} normal form of an unification problem P as $\pNF{P}$. So the problem $P$ can be written as
        $$\pNF{P} = \pair{\Delta}{s_1' \eqUnif t_1', \cdots, s_l' \eqUnif t_l'}$$
        We call $\Delta$ an \textbf{initial context} and the equational predicates $s_i \eqUnif t_i$ the equations that remains to be solved.

        From now on we always consider problems in normal forms.
    \end{frame}

    \begin{frame}{Unification Problems}
        A solution of an unification problem $P$ is a pair $(\Gamma, \sigma)$ of a consistent context $\Gamma$ and a substitution $\sigma$ such that:
        \begin{enumerate}
            \item $\Gamma \vdash \Delta \sigma$.
            \item $\Gamma \vdash s_i \sigma \eqUnif t_i \sigma$, for all $1 \leq i \leq n$.
        \end{enumerate}
        We write $\sol{Pr}$ for the set of all solutions of $P$.
    \end{frame}

    \begin{frame}{An Algorithm for Nominal Unification}
        We now derive an \textit{algorithm} for nominal unification by enriching the \textit{simplification rules} with the two following additional rules: (as done in \cite{gabbay:nomr-jv}).
        \begin{align*}
            \pAction{\pi}{X} \eqUnif u, P & \xrightarrow{X \mapsto \pAction{\pi^{-1}}{u}}{P[X \mapsto \pAction{\pi^{-1}}{u} ]} \quad (X \notin \vars{u}) \\
            u \eqUnif \pAction{\pi}{X}, P & \xrightarrow{X \mapsto \pAction{\pi^{-1}}{u}}{P[X \mapsto \pAction{\pi^{-1}}{u} ]} \quad (X \notin \vars{u})
        \end{align*}

        We denote this algorithm as $\algUnif{P}$ or if we need to be more specific $\algUnif{\Delta, s_1 \aeq t_1, \cdots, s_n \aeq t_n}$.
    \end{frame}

    \begin{frame}{Instantiation}
        We order solutions by the \textit{instantiation order:} We say $(\Gamma_2, \sigma_2)$ is an \textit{instance} of $(\Gamma_1, \sigma_1)$ iff there exists a substitution $\delta$ such that for all variables $X$ the following conditions hold:
        \begin{enumerate}
            \item $\Gamma_2 \vdash X \sigma_2 \aeq X \sigma_1 \delta$.
            \item $\Gamma_2 \vdash \Gamma_1 \delta$.
        \end{enumerate}

        We denote this fact by writing:
        $$(\Gamma_1, \sigma_1) \instOrder_\delta (\Gamma_2, \sigma_2)$$
    \end{frame}

    \begin{frame}{Instantiation of Solutions}
        \begin{lemma}
            The instantiation order is a partial order on $\sol{P}$. (\cite{gabbay:nomr-jv})
        \end{lemma}
    \end{frame}




    \section{Nominal Disunification}

    \begin{frame}{Disunification Problems}
        Now we discuss an extension to the nominal syntax of the work on First Order Disunification done by W. Buntine and H. B\"{u}rckert in \cite{Buntine:1994:SED:179812.179813}.
    \end{frame}

    \begin{frame}{Disunification Problems}
        \begin{definition}
            A \textit{nominal disunification problem} $P$ is an ordered pair $P = \pair{E}{D}$ where $E$ is an equational problem and $D$ is a \textit{disequational problem} as follows:
            $$E = \pair{\Delta}{s_1 \eqUnif t_1, \cdots, s_n \eqUnif t_n}$$
            $$D = \pair{\nabla}{p_1 \eqDis q_1, \cdots, p_m \eqDis q_m}$$
            and $\Delta, \nabla$ are consistent contexts. We call them the \textbf{initial contexts} of the problem $P$.
        \end{definition}

        \begin{remark}
            We consider $\Delta, \nabla$ as the initial freshness constraints we impose on equations and disequations of $P$, respectively.
        \end{remark}
    \end{frame}

    \begin{frame}{Example}
        \begin{example}
            \begin{align*}
                P_1 & = \pair{\emptyset, X \eqUnif Y }{\emptyset, X \eqDis a}                                             \\
                P_2 & = \pair{b\fresh Z, \pAction{\swapping{b}{a}}{X} \eqUnif Y}{\emptyset, \abs{a}{X} \eqDis \abs{b}{Y}}
            \end{align*}
        \end{example}
    \end{frame}

    \begin{frame}{Solutions to Disunification}
        \begin{definition}
            A solution to a disunification problem $P = \pair{E}{D}$ is a pair $(\Gamma, \sigma)$ of a consistent context $\Gamma$ and a substitution $\sigma$ satisfying the following conditions:
            \begin{enumerate}
                \item $(\Gamma, \sigma)$ is a solution of $E$.
                \item $(\Gamma, \sigma)$ satisfies the disequations in $D$. That is:
                      \begin{enumerate}
                          \item $\Gamma \nvdash \Delta \sigma$, or
                          \item $\Gamma \nvdash p \aeq q$, for all $p \adis q$ in $D$.
                      \end{enumerate}
            \end{enumerate}
        \end{definition}
    \end{frame}

    \begin{frame}{Restricted Instantiation}
        \begin{definition}
            A ``pair with exception'' is a pair $\pairEx{\Gamma}{\sigma}{\Psi}$ of a \textbf{pair} $\pair{\Gamma}{\sigma}$ and an indexed family of \textbf{pairs} $\Psi = \{ (\nabla_l, \psi_l) \mid l \in I \}$
        \end{definition}.
    \end{frame}

    \begin{frame}{Restricted Instantiation}
        \begin{definition}
            We say a \textbf{pair} $(\Gamma, \sigma)$ is an instance of a family $\Psi$ iff each instance of $(\Gamma, \sigma)$ is a instance of some $(\nabla_l,\psi_l) \in \Psi$.

            We then write $\Psi \instOrder (\Gamma, \sigma)$.
        \end{definition}
    \end{frame}

    \begin{frame}{Restricted Instantiation}
        \begin{definition}
            A pair $(\Delta, \lambda)$ is an instance of a ``pair with exceptions'' $\pairEx{\Gamma}{\sigma}{\Psi}$ iff $(\Delta, \lambda)$ is an instance of $(\Gamma, \sigma)$ but not an instance of $\Psi$.
        \end{definition}
        We denote this fact by $\pairEx{\Gamma}{\sigma}{\Psi} \instOrder (\Delta, \lambda)$.
    \end{frame}

    \begin{frame}{Restricted Instantiation}
        \begin{definition}
            We call a ``pair with exceptions'' $\pairEx{\Gamma}{\sigma}{\Psi}$ consistent iff it has at least one instace.
        \end{definition}
    \end{frame}

    \begin{frame}{Inconsistence Characterization}
        \begin{lemma}[Inconsistence Lemma]
            A ``pair with exceptions'' $\pairEx{\Gamma}{\sigma}{\Psi}$ is inconsistent iff $(\Gamma, \sigma)$ is an instance of $\Psi$.
        \end{lemma}
    \end{frame}

    \begin{frame}{Inconsistence Characterization}
        \begin{corollary}
            Let $\pairEx{\Gamma}{\sigma}{\Psi}$ be a ``pair with exceptions''. If there is some $(\nabla_l, \psi_l) \in \Psi$ such that: there exists $\delta$ a substitution, for all $X$,
            $$\Gamma \vdash X\sigma \aeq X \psi_l\delta$$
            Then $\pairEx{\Gamma}{\sigma}{\Psi}$ is inconsistent iff $\Gamma \cap \nabla_l \neq emptyset$ or $\Gamma \vdash X\delta$.
        \end{corollary}
    \end{frame}

    \begin{frame}{Representation of Solutions}
        As with the case for unification problems we are interested in generate a \textit{complete set} of solutions to a disunification problem $P$.
        \begin{definition}
            We call a set $S$ of ``pair with exceptions'' a \textit{complete representation} of solutions to the disunification problem $P$ iff $S$ satisfies the following conditions:
            \begin{enumerate}
                \item If $(\Delta, \lambda) \geq \pairEx{\Gamma}{\sigma}{\Psi}$ for some $\pairEx{\Gamma}{\sigma}{\Psi}$ in $S$ then $(\Delta, \lambda)$ solves $P$.
                \item If $(Delta, \lambda)$ solves $P$ then it is an instance of some $\pairEx{\Gamma}{\sigma}{\Psi}$ in $S$.
                \item $\pairEx{\Gamma}{\sigma}{\Psi}$ is consistent for all $\pairEx{\Gamma}{\sigma}{\Psi} \in S$.
            \end{enumerate}
        \end{definition}
    \end{frame}

    % \begin{frame}{Representation Theorem}
    %     Let $c\sol{P}$ the complete set of solutions to a nominal unification problem $P$.

    %     \begin{remark}
    %         Unification in presence of only $\alpha$-equivalence is unitary.
    %     \end{remark}
    % \end{frame}

    \begin{frame}{Representation Theorem}
        \begin{theorem}
            Let $P = \pair{\Delta, s_1 \eqUnif t_1, \cdots, s_n \eqUnif t_n}{\nabla, p_1 \eqDis q_1, \cdots, p_m \eqDis q_m }$ be a disunification problem. Define the family
            $$\Psi := \bigcup\limits_{p \eqDis q \in D} c\sol{p \eqUnif q}$$
            Then the set $$S = \{ \pairEx{\Gamma}{\sigma}{\Psi} \mid (\Gamma, \sigma) \in c\sol{E} \text{ but not } \Psi (\Gamma, \sigma) \}$$
            is a complete representation of solutions to the problem $P$.
        \end{theorem}
    \end{frame}

    \begin{frame}{Inconsistence Algorithm}
        \begin{algorithm}[H]
            \SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
            \SetKwFunction{Matching}{$\mathtt{matching}$}\SetKwFunction{FindCompress}{FindCompress}
            \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

            \Input{$\pairEx{\Gamma}{\sigma}{\psi}$ a finite pair with exceptions}
            \Output{\textbf{BOOL:} True if the input is consistent False otherwise}
            LET CON : BOOL \;
            \ForEach{$(\nabla_l, \psi_l) \in \Psi$}{
                \eIf{\Matching{$(\Gamma, X\sigma \aeq X \psi_l) = (\Gamma',\delta)$}}{
                    \eIf{$\Gamma \cap \nabla_l \neq \emptyset \ \ OR \ \ \Gamma \vdash X\delta$}{
                        RETURN FALSE AND STOP
                    }{
                        CON := TRUE
                    }
                }{
                    RETURN FALSE AND STOP
                }
            }
            \caption{Inconsistence Algorithm}
        \end{algorithm}
    \end{frame}

    \begin{frame}{Disunification Algorithm}
        \begin{algorithm}[H]
            \SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
            \SetKwFunction{Unify}{$\mathtt{Unify}$}\SetKwFunction{Consistent}{Consistent}
            \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

            \Input{A disunification problem $P = \pair{E}{D}$.}
            \Output{a set $S$ of pair with exceptions (can be emptyset)}

            LET $(\Gamma, \sigma) :=  \Unify{E}$ \;
            LET $\Psi := \bigcup\limits_{p_i \eqDis q_i \in D}  \{ (\nabla_i, \psi_i) = \Unify{$\nabla, p_i \eqUnif q_i$} \}$ \;

            \eIf{$\Consistent{$\pairEx{\Gamma}{\sigma}{\Psi}$}$}{
                RETURN $\pairEx{\Gamma}{\sigma}{\Psi}$
            }{
                RETURN $\emptyset$ and STOP
            }
            \caption{Disunification Algorithm}
        \end{algorithm}
    \end{frame}

    \begin{frame}{Future Work}
        We plan to continue working on Nominal Disunification. That's our task list:
        \begin{enumerate}
            \item Extend Disunification to Nominal Equational Theories $E$ (in the the context of Nominal Universal Algebras, \cite{gabbay:nomuae}), like $AC$ and $C$ for example.
            \item Study more general equational problems, like \textit{Disunification with parameters}.
        \end{enumerate}
    \end{frame}

    \begin{frame}[allowframebreaks]{References}
        \bibliography{References/references}
        \bibliographystyle{abbrv}
    \end{frame}

    \begin{frame}[standout]
        Thank you.
    \end{frame}
\end{document}
