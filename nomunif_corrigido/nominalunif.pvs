%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Authors: Ana Cristina Rocha Oliveira(*)
%          Mauricio Ayala-Rincon(*)
%          Maribel Fernandez(**)
%          (*)Universidade de Brasilia, (**)King's College London
% Last modified: 27 April 2015
% This is the main subtheory of the theory Nominal Unification
% Here, a functional specification of nominal unification is
% given and formalised its soundness and correcteness.
% 
%                >>>> This is the top theory <<<<
%
% Comments reference Definitions, Lemmas and Theorems from the accompaining report
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nominalunif: THEORY
BEGIN
	IMPORTING substitution,
		  structure_extra[[variable,term]],
		  atoms

	Delta, Nabla: VAR fresh_context
	sigma, gamma, theta: VAR Sub
	t, s, u: VAR term
	X: VAR variable

	% TODO: unify_lst - boolean that indicates whether the algorith unify_wrapper is working as unify or unify_lst
	unify_lst: VAR bool
        lst_t: VAR list[term]
	lst_s: VAR list[term]
	
% TODO: a fixed point equation is a permutation and a variable
fix_pnt_eq: TYPE = [perm, variable]

% TODO: one nominal solution is a list consisting of a fresh context and a substitution. 
nominal_sol:  TYPE = [fresh_context, Sub, list[fix_pnt_eq]]

sol: VAR nominal_sol
sol_lst: VAR list[nominal_sol]


% Two terms are unifiable if there is a solution (Delta, sigma)
% that makes them alpha-equivalent.
% Definition 4.1
unifiable?(t, s): bool =
   EXISTS(Delta, sigma): 
   alpha(Delta)(Subs(sigma)(t), Subs(sigma)(s))

% A unifier is a unification solution to unifiable terms.
% Definition 4.1
unifier(t, (s | unifiable?(t,s)))(Delta,sigma): bool =
   alpha(Delta)(Subs(sigma)(t), Subs(sigma)(s))

   	solve1, solve2: VAR [fresh_context, Sub, bool]

% Concatenation of contexts and substitutions/
% conjunction of booleans (concatenating triplets).
x(solve1, solve2): [fresh_context, Sub, bool] =
   IF solve1`3 AND solve2`3
      THEN (append(solve1`1, solve2`1),append(solve1`2, solve2`2), TRUE)
      ELSE ((::), Id, FALSE)
   ENDIF

%%%%%%%%%%%%
% Auxiliar functions for the algorithm unify wrapper
% The following are the auxiliar function for the algorithm:
  % apply subs

%% Function: apply_subs.
%  Receives:
	% 1. A list of nominal solutions, which contains the substitutions to be applied simultaneously to terms t and s
	% 2. A term t
	% 3. A term s 
%  Returns:
	% a list containing two elements. The first element is a list of term. Each term is the result of applying a substitution to the term t.
	% The second element is also a list of terms. Each term is the result of applying the same substitution to the term s
apply_subs(sol_lst, t, s): RECURSIVE [list[term] , list[term]] = 
    IF null(sol_lst) THEN ((::), (::)) 
    ELSE LET sub = car(sol_lst)`2,
	     t_first_lst = (:Subs(sub)(t):),
	     s_first_lst = (:Subs(sub)(t):),
	     (t_tail_lst, s_tail_lst) = apply_subs(cdr(sol_lst), t, s),
	     lst_t = append(t_first_lst, t_tail_lst),
	     lst_s = append(s_first_lst, s_tail_lst) 
	     IN (lst_t, lst_s)
    ENDIF
MEASURE sol_lst BY <<

%%%%%%%%%% END

% The function unify_wrapper encapsulates two functions (unify) and (unify_lst) in one.
% The function unify calls unify_lst, and unify_lst calls unify. However, since PVS does not support mutual recursion, we need to
% encapsulate them both in the same function. A boolean parameter decides which function is currently running. The return type is
% the same for both functions: a list of nominal solutions.
% Function receives:
  % 1. Term t to unify (if we are in function unify)
  % 2. Term s to unify (if we are in function unify) 
  % 3. Boolean unify_lst. If FALSE, we are unifying two terms (we are in function unify). If TRUE, we are unifying two lists (we
               		   % are in function unify_lst)
  % 4. lst_t to unify (if we are in function unify_lst)
  % 5. lst_s to unify (if we are in function unify_lst)
% Function returns
  % a list of nominal solution. The list is empty if no solution could be found.  
unify_wrapper(t, s, unify_lst, lst_t, lst_s): RECURSIVE list[nominal_sol] = 

    % if unify_lst is True, we are trying to unify lst_t and lst_s. 
    IF unify_lst THEN
       IF null(lst_t) OR null(lst_s) THEN (::)
       % append list of solutions of head with list of solutions of tail of the list
       ELSE LET sol_head = unify_wrapper(car(lst_t), car(lst_s), FALSE, (::), (::)),
       	    	sol_tail = unify_wrapper(t, s, TRUE, cdr(lst_t), cdr(lst_s)) IN
		append(sol_head, sol_tail)
       ENDIF

    % if unify_lst is False, we are in the normal algorithm for unifying two terms 
    ELSE
	% handle case of s being a suspended variable not occurring in t
	IF susp?(s) AND NOT occurs(V(s), t) THEN
	LET sol = ( (::), (: (V(s), ext(reverse(p(s)))(t)) :), (::)) IN
	       (:sol:)
	       
	ELSE CASES t of
	     % atom - simple base case of our induction
	     at(a): IF s = at(a) THEN LET sol = ( (::), Id, (::)) IN
	     	       	   	      	  (:sol:)
		    ELSE (::)
		    ENDIF, 

	     % suspended variable - TODO: i am not calling function alpha? (from Ana's specification)
	     *(pm, X): IF NOT occurs(X, s) THEN LET sol = ((::), (: (X, ext(reverse(pm))(s)) :), (::)) IN
	     	       	      		   	    (:sol:)
		       % TODO: here we have a fixed point problem. Adapt algorithm?
		       ELSIF susp?(s) AND occurs(X, s) THEN LET fxd_pnt_eq = (append(pm, reverse(p(s))), X),
		       	     	      	  	       	    	sol = ((::), Id, (:fxd_pnt_eq:)) IN
                       	     	      	  	       	    	(:sol:)
		       ELSE (::)                              % here, t is a suspension and s is not a suspension, but it contains X.
                 	  				      % there is no possible solution
		       ENDIF,

	     % unit - a simple base case of our induction
	     unit: IF s = unit THEN LET sol = ( (::), Id, (::)) IN
	     	      	       	    	(:sol:)
		   ELSE (::)
		   ENDIF,

	     % pair - TODO: i'll need to code 2 auxiliary functions
	     pair(t1, t2): IF NOT pair?(s) THEN (::)
	                   ELSE LET % unify first terms - obtain preliminar list of solutions
			            sol_lst_fst_pre = unify_wrapper(t1, term1(s), FALSE, (::), (::)), 
                                    % apply every possible substitution to second terms
                                    (t2_subs_lst, s2_subs_lst) = apply_subs(sol_lst_fst_pre, t2, term2(s))
				    % unify list of second terms 
				    %sol_lst_snd = unify_wrapper(t, s, TRUE, t2_subs_lst, s2_subs_lst),
				    % applies list of substitutions to list of contexts (if possible) obtaining new contexts for fst solution
				    %sol_lst_fst_final = apply_lst_sub_lst_ctxt(sol_lst_fst_pre, sol_lst_snd)
				    % concatenate lists of solutions
				    IN (::) %append(sol_lst_fst_final, sol_lst_snd)
		           ENDIF,

	     % abstraction - TODO: I will need to code two more functions.
	     abs(a, bd): IF NOT abs?(s) THEN (::)
	       	         ELSIF a = abstr(s) THEN unify_wrapper(bd, body(s), FALSE, (::), (::))
		         ELSE (::) %LET % unify body of abstractions, according to the rules. Obtain preliminar list of solutions
			      %    sol_lst1 = unify_wrapper(bd, ext((:(a, abstr(s)):))(body(s)), FALSE, (::), (::)),
		    	      %    % TODO: computes minimal context in which a is fresh on each solution of the lst of solutions
			      %    %(Delta_lst, bool_lst) = fresh?_lst(a, sol_lst1)
				  % concatenate this list of contexts with the solutions, case the boolean indicate it is possible
				  % IN add_context_aux(Delta_lst, bool_lst, sol_lst1)
		         ENDIF,

	     % application of a function - easy commutative case
             app(f, ag): IF NOT app?(s) OR f /= sym(s) THEN (::)
	     	    	 ELSE unify_wrapper(ag, arg(s), FALSE, (::), (::))
			 ENDIF, 
	     
	     % commutative function - how should we handle commutative functions not being called with a pair?
	     c_app(f, c_arg): IF NOT c_app?(s) OR NOT pair?(arg(t)) OR NOT pair?(arg(s)) OR f /= sym(s) THEN (::)
	     	      	      % try both ways of unifying the pair (t1, t2) with (s1, s2) and concatenate this solutions
	     	      	      ELSE LET sol1_lst = unify_wrapper(pair(term1(arg(t)), term2(arg(t))), pair(term1(arg(s)), term2(arg(s))), FALSE, (::), (::)),
			      	       sol2_lst = unify_wrapper(pair(term1(arg(t)), term2(arg(t))), pair(term2(arg(s)), term1(arg(s))), FALSE, (::), (::))
				       IN append(sol1_lst, sol2_lst) 
			      ENDIF	     
	ENDCASES
    ENDIF
ENDIF
MEASURE lex2(card(Vars(t,s)), depth(t))
% TODO: what is the function lex2?. Here, I need to add the length of lst_t. There is lex3 on PVS 



%%%%%%%%%%%%
%  original function
unify(t,s): RECURSIVE [fresh_context, Subs_unif(t,s), bool] =
   IF susp?(s) AND NOT occurs(V(s), t)
      THEN ((::),(:(V(s),ext(reverse(p(s)))(t)):),TRUE)
      ELSE
   CASES t OF
   	 at(a): ((::),Id,s=at(a)),
	 *(pm,X): IF NOT occurs(X,s) THEN ((::),(:(X,ext(reverse(pm))(s)):),TRUE)
	 	     ELSE LET SOL = alpha?(pm * X, s) IN
		     	  (SOL`1,Id,SOL`2) ENDIF,
	 unit: ((::),Id,s=unit),
	 pair(t1,t2): IF NOT pair?(s) THEN ((::), Id, FALSE) 
	 	      	 ELSE LET (Delta1, sig1, b1) = unify(t1,term1(s)),
			      	  (Delta2, sig2, b2) = unify(Subs(sig1)(t2),Subs(sig1)(term2(s))),
			      	  (Delta3, b3) = fresh_subs?(sig2, Delta1) IN
			          x((Delta2,sig2,b2), (Delta3,sig1, b1 AND b3)) ENDIF,	
	 abs(a,bd): IF NOT abs?(s) THEN ((::), Id, FALSE)
		       ELSIF a = abstr(s)
			     THEN unify(bd, body(s))	
			     ELSE LET (Delta1, sig, b1) = unify(bd, ext((:(a,abstr(s)):))(body(s))),
				      (Delta2, b2) = fresh?(a, Subs(sig)(body(s))) IN
				      x((Delta2, Id, b2), (Delta1, sig, b1)) ENDIF,
	 app(f,ag): IF NOT app?(s) OR f /= sym(s) THEN ((::), Id, FALSE)
		       ELSE unify(ag, arg(s)) ENDIF
ENDCASES ENDIF
MEASURE lex2(card(Vars(t,s)), depth(t))

% Soundness of unify.
unify_sound: LEMMA % Lemma 4.10
   LET (Delta, sig, b) = unify(t, s) IN
   b => alpha(Delta)(Subs(sig)(t), Subs(sig)(s))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Partial order over pairs (Context x substitution).
less((Delta, sigma), (Nabla,gamma)): bool = % Definition 4.11
   EXISTS theta:
   fresh_subs(Nabla)(theta, Delta) AND
   FORALL X : alpha(Nabla)(Subs(append(theta,sigma))((::)*X), Subs(gamma)((::)*X))

% Completeness of unify.
unify_complete: THEOREM % Theorem 4.12
   LET (Nabla, gamma, b) = unify(t, s) IN
   alpha(Delta)(Subs(sigma)(t), Subs(sigma)(s)) 
   IMPLIES b AND less(Nabla, gamma, Delta, sigma)

END nominalunif
